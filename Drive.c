#pragma config(Hubs,  S1, MatrxRbtcs, none,     none,     none)
#pragma config(Hubs,  S2, MatrxRbtcs, none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Sensor, S3,     BumpBottomLift, sensorTouch)
#pragma config(Motor,  motorA,          Intake_Left,   tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          Intake_Right,  tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_Matrix_S1_1, LiftRight,     tmotorMatrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_2, Right_Back,    tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_Matrix_S1_3, Right_Front,   tmotorMatrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S1_4, Conveyor,      tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_Matrix_S2_1, LiftLeft,      tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_Matrix_S2_2, Spindle,       tmotorMatrix, openLoop, encoder)
#pragma config(Motor,  mtr_Matrix_S2_3, Left_Back,     tmotorMatrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_Matrix_S2_4, Left_Front,    tmotorMatrix, openLoop, encoder)
#pragma config(Servo,  srvo_Matrix_S1_1, BoxDoor,              tServoStandard)
#pragma config(Servo,  srvo_Matrix_S1_2, servo2,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S1_3, BoxArm,               tServoStandard)
#pragma config(Servo,  srvo_Matrix_S1_4, servo4,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_1, servo5,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_2, servo6,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_3, servo7,               tServoNone)
#pragma config(Servo,  srvo_Matrix_S2_4, Holder,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Drive Variables
int leftEncoderValue;
int rightEncoderValue;

const int ticksPerRotation = 360;
const float wheelCircumferenceInches = 11.8737;

const float kPDrive = 0.045;
const int acceptableDriveError = 50;
const int driveJoystickDeadzone = 5;
const int maxAutonomousOutput = 70;
const int minAutonomousOutput = 45;

void tankDrive(int leftSpeed, int rightSpeed)
{
	motor[Left_Front] = leftSpeed;
	motor[Left_Back] = leftSpeed;
	motor[Right_Front] = rightSpeed;
	motor[Right_Back] = rightSpeed;
}

void zeroDriveEncoders()
{
	nMotorEncoder[Left_Back] = 0;
	nMotorEncoder[Left_Front] = 0;
	nMotorEncoder[Right_Back] = 0;
	nMotorEncoder[Right_Front] = 0;
}

int getLeftEncoderValue()
{
	return -nMotorEncoder[Left_Back];
}

int getRightEncoderValue()
{
	return -nMotorEncoder[Right_Back];
}


/*
 * Autonomously drive until a certain number of ticks
 * Returns whether or not it ran out of time
 */
bool driveUntilTicks(int leftTicks, int rightTicks, float timeout)
{
	zeroDriveEncoders();

	ClearTimer(T1);

	bool leftAtTarget, rightAtTarget = false;

	while(!leftAtTarget && !rightAtTarget && time1[T1] < (timeout * 1000))
	{
		int leftDriveError = leftTicks - nMotorEncoder[Left_Back];
		int rightDriveError = rightTicks - nMotorEncoder[Right_Back];

		leftDriveError = abs(leftDriveError) > acceptableDriveError ? leftDriveError : 0;
		rightDriveError = abs(rightDriveError) > acceptableDriveError ? rightDriveError : 0;

		leftAtTarget = leftDriveError == 0;
		rightAtTarget = rightDriveError == 0;

		tankDrive(leftDriveError * kPDrive, rightDriveError * kPDrive);
	}

	tankDrive(0, 0);

	return leftAtTarget && rightAtTarget;
}

bool driveUntilTicks(int ticks, float timeout)
{
	zeroDriveEncoders();

	ClearTimer(T1);

	bool atTarget = false;

	while(!atTarget && time1[T1] < (timeout * 1000))
	{
		int encoderValue = getLeftEncoderValue();

		int driveError = ticks - encoderValue;

		if(ticks < 0 && encoderValue < ticks)
		{
			driveError = 0;
		}
		else if(ticks > 0 && encoderValue > ticks)
		{
			driveError = 0;
		}

		driveError = abs(driveError) > acceptableDriveError ? driveError : 0;

		atTarget = driveError == 0;

		int motorOutput = driveError * kPDrive;
		motorOutput = motorOutput > 0 && motorOutput > maxAutonomousOutput ? maxAutonomousOutput : motorOutput;
		motorOutput = motorOutput < 0 && motorOutput < -maxAutonomousOutput ? -maxAutonomousOutput : motorOutput;
		motorOutput = motorOutput > 0 && motorOutput < minAutonomousOutput ? minAutonomousOutput : motorOutput;
		motorOutput = motorOutput < 0 && motorOutput > -minAutonomousOutput ? -minAutonomousOutput : motorOutput;

		tankDrive(motorOutput, motorOutput);
	}

	tankDrive(0, 0);

	return atTarget;
}

bool turnTicks(int ticks, float timeout)
{
	zeroDriveEncoders();

	ClearTimer(T1);

	bool atTarget = false;

	while(!atTarget && time1[T1] < (timeout * 1000))
	{
		int encoderValue = getLeftEncoderValue();

		int driveError = ticks - encoderValue;

		if(ticks < 0 && encoderValue < ticks)
		{
			driveError = 0;
		}
		else if(ticks > 0 && encoderValue > ticks)
		{
			driveError = 0;
		}

		driveError = abs(driveError) > acceptableDriveError ? driveError : 0;

		atTarget = driveError == 0;

		int motorOutput = driveError * kPDrive;
		motorOutput = motorOutput > 0 && motorOutput > maxAutonomousOutput ? maxAutonomousOutput : motorOutput;
		motorOutput = motorOutput < 0 && motorOutput < -maxAutonomousOutput ? -maxAutonomousOutput : motorOutput;
		motorOutput = motorOutput > 0 && motorOutput < minAutonomousOutput ? minAutonomousOutput : motorOutput;
		motorOutput = motorOutput < 0 && motorOutput > -minAutonomousOutput ? -minAutonomousOutput : motorOutput;

		tankDrive(motorOutput, -motorOutput);
	}

	tankDrive(0, 0);

	return atTarget;
}

bool driveForInches(int inches, float timeout)
{
	zeroDriveEncoders();

	ClearTimer(T1);

	return true;
}

void lowerHook()
{
	servo[Holder] = 255;
}

void raiseHook()
{
	servo[Holder] = 0;
}

void halfHook()
{
	servo[Holder] = 127;
}

task printEncoderValues()
{
	while(true)
	{

		leftEncoderValue = getLeftEncoderValue();
		rightEncoderValue = getRightEncoderValue();

		nxtDisplayCenteredTextLine(4, "%d", leftEncoderValue);
		nxtDisplayCenteredTextLine(6, "%d", rightEncoderValue);
	}
}
